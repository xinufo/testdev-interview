# Hashtable和HashMap

## 数据结构

数组 + 链表（HashMap在jdk 1.8有优化链表可能会变成红黑树），先算出key的hash码，然后对数组长度求余数得出索引位置，然后将元素放入数组，若多个元素索引位置相同则将它们组成链表

## Hashtable

key和value不允许为NULL。是线程安全的，因为在每个方法上都加了synchronized关键字，因为synchronized方法锁住的是this对象所以并发度不高。

### get

先算出key的hash码，然后对数组长度求余数得出索引位置，从索引位置取出链表头，遍历找出key对应的value

### put

先算出key的hash码，然后对数组长度求余数得出索引位置，从索引位置取出链表头开始遍历，如果存在key则替换value，否则新建一个Entry插入到链表头部

### 扩容

在put时若没有对应的key，则会新建Enrty，此时会判断当前元素数量是否大于阈值（容量 * 负载因子），若大于则需要扩容以减少哈希碰撞。扩容时首先申请一个长度为`原数组长度 * 2 + 1`的新数组，然后遍历原数组中的元素进行rehash，具体过程与put类似。注意，因为链表采用的是头插法，因此扩容后链表可能变为原来的倒序。

## HashMap

key和value允许为NULL（因为HashMap中对NULL做了特殊处理），不是线程安全的。

### get

整体过程与Hashtable类似，但是HashMap（jdk 1.8）改进了一些地方：

1. 在求余数时用的是`(len - 1) & hash`，因此数组长度为2的整数次幂，所以可以用位运算提高速度。
2. 求hash码时进行了`(h = key.hashCode()) ^ (h >>> 16)`，因为数组长度为2的整数次幂（二进制中仅一个1），在求余数时结果只与数组长度二进制1之后的位有关，也就是所如果两个hash码仅在高于数组长度二进制1的位上不同，则这两个hash码算出来的索引必然相同；所以将高16位与低16位异或，引入高位的影响来减少哈希碰撞。

> 例如数组长度为8，二进制位00001000，hash1为88，二进制位01011000，hash2为104，二进制为01101000，hash1和hash2仅在高于第3位（从0开始）不同，所以两者对8求余数相等。

### put

先算出key的hash码，然后对数组长度求余数得出索引位置，若当前索引位置为null，则新建Node放入，否则开始遍历，如果存在key则替换value，否则新建一个Entry插入到链表头部

> jdk 1.8优化：当数组位置不是null时会判断当前位置是链表还是树，是树就通过putTreeVal方法设置value，否则遍历链表如果存在key则替换value，否则新建一个Entry插入到链表尾部。注意此处插入链表不再使用头插法，因此扩容后链表会保持原顺序（在jdk 1.7中采用的头插法，所以在多线程put时可能出现链表成环进而死循环）。在插入链表完成后会检查链表长度，如果大于8则将链表转换为红黑树以减少查询时间。

### 扩容

扩容机制与Hashtable类似，但是在元素迁移时进行了优化：会通过(e.hash & oldCap) == 0判断元素是否需要移动。因为新数组长度为原来的2倍，且是2的整数次幂，所以就相当于在求余数时就只比原来多了一位参与运算，如果这多的一位是0就说明对结果没有影响不需要移动，否则就说明需要移动；`(len - 1) & hash`运算相当于取hash中低于len中1的低位，hash多了一位参与运算，那么也就相当于结果直接多了一位，而多出来的正好是oldCap二进制1的位置，所以直接加上oldCap就可以了（`oldIndex | oldCap`应该也可以）；因此新的索引位置只可能是以下两种情况，1.与原来一样；2.等于原索引 + 原数组长度。